{"ast":null,"code":"import { ɵgetAllInstancesOf as _getAllInstancesOf, ɵgetDefaultInstanceOf as _getDefaultInstanceOf, VERSION, ɵAngularFireSchedulers as _AngularFireSchedulers, ɵAppCheckInstances as _AppCheckInstances, ɵzoneWrap as _zoneWrap } from '@angular/fire';\nimport { timer, from } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Optional, NgModule, makeEnvironmentProviders, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { AuthInstances } from '@angular/fire/auth';\nimport { registerVersion } from 'firebase/app';\nimport { collectionChanges as collectionChanges$1, collection as collection$1, sortedChanges as sortedChanges$1, auditTrail as auditTrail$1, collectionData as collectionData$1, collectionCountSnap as collectionCountSnap$1, collectionCount as collectionCount$1, doc as doc$1, docData as docData$1, snapToData as snapToData$1, fromRef as fromRef$1 } from 'rxfire/firestore';\nimport { addDoc as addDoc$1, aggregateFieldEqual as aggregateFieldEqual$1, aggregateQuerySnapshotEqual as aggregateQuerySnapshotEqual$1, and as and$1, arrayRemove as arrayRemove$1, arrayUnion as arrayUnion$1, average as average$1, clearIndexedDbPersistence as clearIndexedDbPersistence$1, collection as collection$2, collectionGroup as collectionGroup$1, connectFirestoreEmulator as connectFirestoreEmulator$1, count as count$1, deleteAllPersistentCacheIndexes as deleteAllPersistentCacheIndexes$1, deleteDoc as deleteDoc$1, deleteField as deleteField$1, disableNetwork as disableNetwork$1, disablePersistentCacheIndexAutoCreation as disablePersistentCacheIndexAutoCreation$1, doc as doc$2, documentId as documentId$1, enableIndexedDbPersistence as enableIndexedDbPersistence$1, enableMultiTabIndexedDbPersistence as enableMultiTabIndexedDbPersistence$1, enableNetwork as enableNetwork$1, enablePersistentCacheIndexAutoCreation as enablePersistentCacheIndexAutoCreation$1, endAt as endAt$1, endBefore as endBefore$1, getAggregateFromServer as getAggregateFromServer$1, getCountFromServer as getCountFromServer$1, getDoc as getDoc$1, getDocFromCache as getDocFromCache$1, getDocFromServer as getDocFromServer$1, getDocs as getDocs$1, getDocsFromCache as getDocsFromCache$1, getDocsFromServer as getDocsFromServer$1, getFirestore as getFirestore$1, getPersistentCacheIndexManager as getPersistentCacheIndexManager$1, increment as increment$1, initializeFirestore as initializeFirestore$1, limit as limit$1, limitToLast as limitToLast$1, loadBundle as loadBundle$1, memoryEagerGarbageCollector as memoryEagerGarbageCollector$1, memoryLocalCache as memoryLocalCache$1, memoryLruGarbageCollector as memoryLruGarbageCollector$1, namedQuery as namedQuery$1, onSnapshot as onSnapshot$1, onSnapshotsInSync as onSnapshotsInSync$1, or as or$1, orderBy as orderBy$1, persistentLocalCache as persistentLocalCache$1, persistentMultipleTabManager as persistentMultipleTabManager$1, persistentSingleTabManager as persistentSingleTabManager$1, query as query$1, queryEqual as queryEqual$1, refEqual as refEqual$1, runTransaction as runTransaction$1, serverTimestamp as serverTimestamp$1, setDoc as setDoc$1, setIndexConfiguration as setIndexConfiguration$1, setLogLevel as setLogLevel$1, snapshotEqual as snapshotEqual$1, startAfter as startAfter$1, startAt as startAt$1, sum as sum$1, terminate as terminate$1, updateDoc as updateDoc$1, waitForPendingWrites as waitForPendingWrites$1, where as where$1, writeBatch as writeBatch$1 } from 'firebase/firestore';\nexport * from 'firebase/firestore';\nclass Firestore {\n  constructor(firestore) {\n    return firestore;\n  }\n}\nconst FIRESTORE_PROVIDER_NAME = 'firestore';\nclass FirestoreInstances {\n  constructor() {\n    return _getAllInstancesOf(FIRESTORE_PROVIDER_NAME);\n  }\n}\nconst firestoreInstance$ = /*#__PURE__*/ /*#__PURE__*/timer(0, 300).pipe( /*#__PURE__*/concatMap(() => from(_getAllInstancesOf(FIRESTORE_PROVIDER_NAME))), /*#__PURE__*/distinct());\nconst PROVIDED_FIRESTORE_INSTANCES = /*#__PURE__*/new InjectionToken('angularfire2.firestore-instances');\nfunction defaultFirestoreInstanceFactory(provided, defaultApp) {\n  const defaultFirestore = _getDefaultInstanceOf(FIRESTORE_PROVIDER_NAME, provided, defaultApp);\n  return defaultFirestore && new Firestore(defaultFirestore);\n}\nfunction firestoreInstanceFactory(fn) {\n  return (zone, injector) => {\n    const firestore = zone.runOutsideAngular(() => fn(injector));\n    return new Firestore(firestore);\n  };\n}\nconst FIRESTORE_INSTANCES_PROVIDER = {\n  provide: FirestoreInstances,\n  deps: [[/*#__PURE__*/new Optional(), PROVIDED_FIRESTORE_INSTANCES]]\n};\nconst DEFAULT_FIRESTORE_INSTANCE_PROVIDER = {\n  provide: Firestore,\n  useFactory: defaultFirestoreInstanceFactory,\n  deps: [[/*#__PURE__*/new Optional(), PROVIDED_FIRESTORE_INSTANCES], FirebaseApp]\n};\nlet FirestoreModule = /*#__PURE__*/(() => {\n  class FirestoreModule {\n    constructor() {\n      registerVersion('angularfire', VERSION.full, 'fst');\n    }\n    static ɵfac = function FirestoreModule_Factory(t) {\n      return new (t || FirestoreModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: FirestoreModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [DEFAULT_FIRESTORE_INSTANCE_PROVIDER, FIRESTORE_INSTANCES_PROVIDER]\n    });\n  }\n  return FirestoreModule;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideFirestore(fn, ...deps) {\n  registerVersion('angularfire', VERSION.full, 'fst');\n  return makeEnvironmentProviders([DEFAULT_FIRESTORE_INSTANCE_PROVIDER, FIRESTORE_INSTANCES_PROVIDER, {\n    provide: PROVIDED_FIRESTORE_INSTANCES,\n    useFactory: firestoreInstanceFactory(fn),\n    multi: true,\n    deps: [NgZone, Injector, _AngularFireSchedulers, FirebaseApps,\n    // Firestore+Auth work better if Auth is loaded first\n    [new Optional(), AuthInstances], [new Optional(), _AppCheckInstances], ...deps]\n  }]);\n}\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst collectionChanges = /*#__PURE__*/_zoneWrap(collectionChanges$1, true);\nconst collectionSnapshots = /*#__PURE__*/_zoneWrap(collection$1, true);\nconst sortedChanges = /*#__PURE__*/_zoneWrap(sortedChanges$1, true);\nconst auditTrail = /*#__PURE__*/_zoneWrap(auditTrail$1, true);\nconst collectionData = /*#__PURE__*/_zoneWrap(collectionData$1, true);\nconst collectionCountSnap = /*#__PURE__*/_zoneWrap(collectionCountSnap$1, true);\nconst collectionCount = /*#__PURE__*/_zoneWrap(collectionCount$1, true);\nconst docSnapshots = /*#__PURE__*/_zoneWrap(doc$1, true);\nconst docData = /*#__PURE__*/_zoneWrap(docData$1, true);\nconst snapToData = /*#__PURE__*/_zoneWrap(snapToData$1, true);\nconst fromRef = /*#__PURE__*/_zoneWrap(fromRef$1, true);\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst addDoc = /*#__PURE__*/_zoneWrap(addDoc$1, true);\nconst aggregateFieldEqual = /*#__PURE__*/_zoneWrap(aggregateFieldEqual$1, true);\nconst aggregateQuerySnapshotEqual = /*#__PURE__*/_zoneWrap(aggregateQuerySnapshotEqual$1, true);\nconst and = /*#__PURE__*/_zoneWrap(and$1, true);\nconst arrayRemove = /*#__PURE__*/_zoneWrap(arrayRemove$1, true);\nconst arrayUnion = /*#__PURE__*/_zoneWrap(arrayUnion$1, true);\nconst average = /*#__PURE__*/_zoneWrap(average$1, true);\nconst clearIndexedDbPersistence = /*#__PURE__*/_zoneWrap(clearIndexedDbPersistence$1, true);\nconst collection = /*#__PURE__*/_zoneWrap(collection$2, true);\nconst collectionGroup = /*#__PURE__*/_zoneWrap(collectionGroup$1, true);\nconst connectFirestoreEmulator = /*#__PURE__*/_zoneWrap(connectFirestoreEmulator$1, true);\nconst count = /*#__PURE__*/_zoneWrap(count$1, true);\nconst deleteAllPersistentCacheIndexes = /*#__PURE__*/_zoneWrap(deleteAllPersistentCacheIndexes$1, true);\nconst deleteDoc = /*#__PURE__*/_zoneWrap(deleteDoc$1, true);\nconst deleteField = /*#__PURE__*/_zoneWrap(deleteField$1, true);\nconst disableNetwork = /*#__PURE__*/_zoneWrap(disableNetwork$1, true);\nconst disablePersistentCacheIndexAutoCreation = /*#__PURE__*/_zoneWrap(disablePersistentCacheIndexAutoCreation$1, true);\nconst doc = /*#__PURE__*/_zoneWrap(doc$2, true);\nconst documentId = /*#__PURE__*/_zoneWrap(documentId$1, true);\nconst enableIndexedDbPersistence = /*#__PURE__*/_zoneWrap(enableIndexedDbPersistence$1, true);\nconst enableMultiTabIndexedDbPersistence = /*#__PURE__*/_zoneWrap(enableMultiTabIndexedDbPersistence$1, true);\nconst enableNetwork = /*#__PURE__*/_zoneWrap(enableNetwork$1, true);\nconst enablePersistentCacheIndexAutoCreation = /*#__PURE__*/_zoneWrap(enablePersistentCacheIndexAutoCreation$1, true);\nconst endAt = /*#__PURE__*/_zoneWrap(endAt$1, true);\nconst endBefore = /*#__PURE__*/_zoneWrap(endBefore$1, true);\nconst getAggregateFromServer = /*#__PURE__*/_zoneWrap(getAggregateFromServer$1, true);\nconst getCountFromServer = /*#__PURE__*/_zoneWrap(getCountFromServer$1, true);\nconst getDoc = /*#__PURE__*/_zoneWrap(getDoc$1, true);\nconst getDocFromCache = /*#__PURE__*/_zoneWrap(getDocFromCache$1, true);\nconst getDocFromServer = /*#__PURE__*/_zoneWrap(getDocFromServer$1, true);\nconst getDocs = /*#__PURE__*/_zoneWrap(getDocs$1, true);\nconst getDocsFromCache = /*#__PURE__*/_zoneWrap(getDocsFromCache$1, true);\nconst getDocsFromServer = /*#__PURE__*/_zoneWrap(getDocsFromServer$1, true);\nconst getFirestore = /*#__PURE__*/_zoneWrap(getFirestore$1, true);\nconst getPersistentCacheIndexManager = /*#__PURE__*/_zoneWrap(getPersistentCacheIndexManager$1, true);\nconst increment = /*#__PURE__*/_zoneWrap(increment$1, true);\nconst initializeFirestore = /*#__PURE__*/_zoneWrap(initializeFirestore$1, true);\nconst limit = /*#__PURE__*/_zoneWrap(limit$1, true);\nconst limitToLast = /*#__PURE__*/_zoneWrap(limitToLast$1, true);\nconst loadBundle = /*#__PURE__*/_zoneWrap(loadBundle$1, true);\nconst memoryEagerGarbageCollector = /*#__PURE__*/_zoneWrap(memoryEagerGarbageCollector$1, true);\nconst memoryLocalCache = /*#__PURE__*/_zoneWrap(memoryLocalCache$1, true);\nconst memoryLruGarbageCollector = /*#__PURE__*/_zoneWrap(memoryLruGarbageCollector$1, true);\nconst namedQuery = /*#__PURE__*/_zoneWrap(namedQuery$1, true);\nconst onSnapshot = /*#__PURE__*/_zoneWrap(onSnapshot$1, true);\nconst onSnapshotsInSync = /*#__PURE__*/_zoneWrap(onSnapshotsInSync$1, true);\nconst or = /*#__PURE__*/_zoneWrap(or$1, true);\nconst orderBy = /*#__PURE__*/_zoneWrap(orderBy$1, true);\nconst persistentLocalCache = /*#__PURE__*/_zoneWrap(persistentLocalCache$1, true);\nconst persistentMultipleTabManager = /*#__PURE__*/_zoneWrap(persistentMultipleTabManager$1, true);\nconst persistentSingleTabManager = /*#__PURE__*/_zoneWrap(persistentSingleTabManager$1, true);\nconst query = /*#__PURE__*/_zoneWrap(query$1, true);\nconst queryEqual = /*#__PURE__*/_zoneWrap(queryEqual$1, true);\nconst refEqual = /*#__PURE__*/_zoneWrap(refEqual$1, true);\nconst runTransaction = /*#__PURE__*/_zoneWrap(runTransaction$1, true);\nconst serverTimestamp = /*#__PURE__*/_zoneWrap(serverTimestamp$1, true);\nconst setDoc = /*#__PURE__*/_zoneWrap(setDoc$1, true);\nconst setIndexConfiguration = /*#__PURE__*/_zoneWrap(setIndexConfiguration$1, true);\nconst setLogLevel = /*#__PURE__*/_zoneWrap(setLogLevel$1, true);\nconst snapshotEqual = /*#__PURE__*/_zoneWrap(snapshotEqual$1, true);\nconst startAfter = /*#__PURE__*/_zoneWrap(startAfter$1, true);\nconst startAt = /*#__PURE__*/_zoneWrap(startAt$1, true);\nconst sum = /*#__PURE__*/_zoneWrap(sum$1, true);\nconst terminate = /*#__PURE__*/_zoneWrap(terminate$1, true);\nconst updateDoc = /*#__PURE__*/_zoneWrap(updateDoc$1, true);\nconst waitForPendingWrites = /*#__PURE__*/_zoneWrap(waitForPendingWrites$1, true);\nconst where = /*#__PURE__*/_zoneWrap(where$1, true);\nconst writeBatch = /*#__PURE__*/_zoneWrap(writeBatch$1, true);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Firestore, FirestoreInstances, FirestoreModule, addDoc, aggregateFieldEqual, aggregateQuerySnapshotEqual, and, arrayRemove, arrayUnion, auditTrail, average, clearIndexedDbPersistence, collection, collectionChanges, collectionCount, collectionCountSnap, collectionData, collectionGroup, collectionSnapshots, connectFirestoreEmulator, count, deleteAllPersistentCacheIndexes, deleteDoc, deleteField, disableNetwork, disablePersistentCacheIndexAutoCreation, doc, docData, docSnapshots, documentId, enableIndexedDbPersistence, enableMultiTabIndexedDbPersistence, enableNetwork, enablePersistentCacheIndexAutoCreation, endAt, endBefore, firestoreInstance$, fromRef, getAggregateFromServer, getCountFromServer, getDoc, getDocFromCache, getDocFromServer, getDocs, getDocsFromCache, getDocsFromServer, getFirestore, getPersistentCacheIndexManager, increment, initializeFirestore, limit, limitToLast, loadBundle, memoryEagerGarbageCollector, memoryLocalCache, memoryLruGarbageCollector, namedQuery, onSnapshot, onSnapshotsInSync, or, orderBy, persistentLocalCache, persistentMultipleTabManager, persistentSingleTabManager, provideFirestore, query, queryEqual, refEqual, runTransaction, serverTimestamp, setDoc, setIndexConfiguration, setLogLevel, snapToData, snapshotEqual, sortedChanges, startAfter, startAt, sum, terminate, updateDoc, waitForPendingWrites, where, writeBatch };\n//# sourceMappingURL=angular-fire-firestore.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}